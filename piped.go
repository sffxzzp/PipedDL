package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/cheggaaa/pb/v3"
)

type (
	Piped struct {
		APIUrl string
		High   bool
	}
	AudioStream struct {
		Bitrate    int    `json:"bitrate,omitempty"`
		Codec      string `json:"codec,omitempty"`
		Format     string `json:"format,omitempty"`
		IndexEnd   int    `json:"indexEnd,omitempty"`
		IndexStart int    `json:"indexStart,omitempty"`
		InitStart  int    `json:"initStart,omitempty"`
		InitEnd    int    `json:"initEnd,omitempty"`
		MimeType   string `json:"mimeType,omitempty"`
		Quality    string `json:"quality,omitempty"`
		URL        string `json:"url,omitempty"`
		VideoOnly  bool   `json:"videoOnly,omitempty"`
	}
	VideoStream struct {
		Bitrate    int    `json:"bitrate,omitempty"`
		Codec      string `json:"codec,omitempty"`
		Format     string `json:"format,omitempty"`
		Fps        int    `json:"fps,omitempty"`
		Height     int    `json:"height,omitempty"`
		IndexEnd   int    `json:"indexEnd,omitempty"`
		IndexStart int    `json:"indexStart,omitempty"`
		InitStart  int    `json:"initStart,omitempty"`
		InitEnd    int    `json:"initEnd,omitempty"`
		MimeType   string `json:"mimeType,omitempty"`
		Quality    string `json:"quality,omitempty"`
		URL        string `json:"url,omitempty"`
		VideoOnly  bool   `json:"videoOnly,omitempty"`
		Width      int    `json:"width,omitempty"`
	}
	VideoData struct {
		AudioStreams   []AudioStream `json:"audioStreams,omitempty"`
		Dash           string        `json:"dash,omitempty"`
		Description    string        `json:"description,omitempty"`
		Dislikes       int           `json:"dislikes,omitempty"`
		Duration       int           `json:"duration,omitempty"`
		Hls            string        `json:"hls,omitempty"`
		LbryID         string        `json:"lbryId,omitempty"`
		Likes          int           `json:"likes,omitempty"`
		Livestream     bool          `json:"livestream,omitempty"`
		ProxyURL       string        `json:"proxyUrl,omitempty"`
		RelatedStreams []struct {
			Duration         int    `json:"duration,omitempty"`
			Thumbnail        string `json:"thumbnail,omitempty"`
			Title            string `json:"title,omitempty"`
			UploadedDate     string `json:"uploadedDate,omitempty"`
			UploaderAvatar   string `json:"uploaderAvatar,omitempty"`
			UploaderURL      string `json:"uploaderUrl,omitempty"`
			UploaderVerified bool   `json:"uploaderVerified,omitempty"`
			URL              string `json:"url,omitempty"`
			Views            int    `json:"views,omitempty"`
		} `json:"relatedStreams,omitempty"`
		Subtitles []struct {
			AutoGenerated bool   `json:"autoGenerated,omitempty"`
			Code          string `json:"code,omitempty"`
			MimeType      string `json:"mimeType,omitempty"`
			Name          string `json:"name,omitempty"`
			URL           string `json:"url,omitempty"`
		} `json:"subtitles,omitempty"`
		ThumbnailURL     string        `json:"thumbnailUrl,omitempty"`
		Title            string        `json:"title,omitempty"`
		UploadDate       string        `json:"uploadDate,omitempty"`
		Uploader         string        `json:"uploader,omitempty"`
		UploaderURL      string        `json:"uploaderUrl,omitempty"`
		UploaderVerified bool          `json:"uploaderVerified,omitempty"`
		VideoStreams     []VideoStream `json:"videoStreams,omitempty"`
		Views            int           `json:"views,omitempty"`
	}
	RelatedStream struct {
		Duration         int    `json:"duration,omitempty"`
		Thumbnail        string `json:"thumbnail,omitempty"`
		Title            string `json:"title,omitempty"`
		UploadedDate     string `json:"uploadedDate,omitempty"`
		UploaderAvatar   string `json:"uploaderAvatar,omitempty"`
		UploaderURL      string `json:"uploaderUrl,omitempty"`
		UploaderVerified bool   `json:"uploaderVerified,omitempty"`
		URL              string `json:"url,omitempty"`
		Views            int    `json:"views,omitempty"`
	}
	PlaylistData struct {
		BannerURL      string          `json:"bannerUrl,omitempty"`
		Name           string          `json:"name,omitempty"`
		Nextpage       string          `json:"nextpage,omitempty"`
		RelatedStreams []RelatedStream `json:"relatedStreams,omitempty"`
		ThumbnailURL   string          `json:"thumbnailUrl,omitempty"`
		Uploader       string          `json:"uploader,omitempty"`
		UploaderAvatar string          `json:"uploaderAvatar,omitempty"`
		UploaderURL    string          `json:"uploaderUrl,omitempty"`
		Videos         int             `json:"videos,omitempty"`
	}
)

func cleanFilename(filename string) string {
	invalidCharRegex := regexp.MustCompile(`[<>:"/\\|?*]`)
	cleanedFilename := invalidCharRegex.ReplaceAllString(filename, "")
	cleanedFilename = filepath.Clean(cleanedFilename)
	return cleanedFilename
}

func exists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func getRes(res string) int {
	rnum, _ := strconv.Atoi(strings.TrimRight(res, "p"))
	return rnum
}

func download(filename string, url string) error {
	fmt.Printf("Downloading %s\n", filename)
	if exists(filename) {
		fmt.Printf("%s exists!\n", filename)
		return nil
	}
	out, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer out.Close()
	res, err := http.Get(url)
	if err != nil {
		return err
	}
	defer res.Body.Close()
	fileSize := res.ContentLength
	bar := pb.Full.Start64(fileSize)
	defer bar.Finish()
	reader := bar.NewProxyReader(res.Body)
	_, err = io.Copy(out, reader)
	if err != nil {
		return err
	}
	return err
}

func newPiped(api string, high bool) *Piped {
	return &Piped{
		APIUrl: api,
		High:   high,
	}
}

func (y *Piped) DownList(playlistID string) {
	playlistAPI := fmt.Sprintf("%s/playlists/%s", y.APIUrl, playlistID)
	var playList []RelatedStream
	var playlistData PlaylistData
	var nullData PlaylistData
	for {
		json.Unmarshal(httpGet(playlistAPI), &playlistData)
		playList = append(playList, playlistData.RelatedStreams...)
		if playlistData.Nextpage != "" {
			playlistAPI = fmt.Sprintf("%s/nextpage/playlists/%s?nextpage=%s", y.APIUrl, playlistID, url.QueryEscape(playlistData.Nextpage))
			playlistData = nullData
		} else {
			break
		}
	}
	for _, v := range playList {
		if exists(cleanFilename(v.Title) + ".mp4") {
			continue
		}
		y.DownVideo(v.URL[9:])
	}
}

func (y *Piped) DownVideo(videoID string) {
	downAPI := fmt.Sprintf("%s/streams/%s", y.APIUrl, videoID)
	var videoData VideoData
	json.Unmarshal(httpGet(downAPI), &videoData)
	filename := cleanFilename(videoData.Title)
	if filename == "." {
		fmt.Println("error fetching data...")
		return
	}
	if y.High {
		var video VideoStream
		var audio AudioStream
		for _, v := range videoData.VideoStreams {
			if v.Format == "MPEG_4" {
				if video.Bitrate < v.Bitrate {
					video = v
				}
			}
		}
		download(filename+".video", video.URL)
		for _, a := range videoData.AudioStreams {
			if a.Format == "M4A" {
				if audio.Bitrate < a.Bitrate {
					audio = a
				}
			}
		}
		download(filename+".audio", audio.URL)
		y.Merge(filename)
	} else {
		var video VideoStream
		video.Quality = "0p"
		for _, v := range videoData.VideoStreams {
			if v.Format == "MPEG_4" && !v.VideoOnly {
				if getRes(video.Quality) < getRes(v.Quality) {
					video = v
				}
			}
		}
		download(filename+".mp4", video.URL)
	}
}

func (y *Piped) Merge(filename string) {
	ff := "ffmpeg"
	if exists("./ffmpeg.exe") {
		ff = "./ffmpeg.exe"
	}
	if exists("./ffmpeg") {
		ff = "./ffmpeg"
	}
	exec.Command(ff, "-i", filename+".video", "-i", filename+".audio", "-c", "copy", filename+".mp4").Output()
	os.Remove(filename + ".video")
	os.Remove(filename + ".audio")
}
